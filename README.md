# sqlalchemy-challenge

![alchemy](https://github.com/s0uravk/sqlalchemy-challenge/assets/144293972/e10e7142-5304-45a2-936b-4d78f841192d)

**Accessing data**

In climate_starter.ipynb, engine instances are created using the local path of the SQLite file, which can be changed according to the database being accessed in the following format: "\<protocol\>\:\/\/<username>\:\<password\>\@\<server\>\:\<port\>\/\<fle-path\>". In this case, the protocol is SQLite, with no need for a username or password to access the local SQLite file; the server or host is localhost; no port is required; and then the file path to the file to be accessed, which is in the Resources folder and named hawaii.sqlite, is created to reflect the tables in the SQLite file to be used in Python code. An instance of each table is saved to fetch the data, and a session object is created to link Python to the database. Then data is accessed using session.query and put into the Pandas dataframe, which is then visualized using the Matplotlib library. Data visualization represents precipitation in inches for one year from the most recent observation. Then the minimum, average, and maximum temperature elevations are calculated for the station with the most observations. For the next visualization, data is represented in a histogram for the frequency of different temperatures for one year from the most recent observation for the station with the most observations. Then the session is closed once we are done with the analysis.

**Creating an API**

For the app.py file, at first, the same method is used to reflect the database structure and then create instances of the tables to be accessed. Then, we create an instance of Flask named App, and then the homepage and other routes are created for the app. Here, we can access the data in a sqlite file using these routes in JSON format. Homepage lists the different routes we have in this app, and the second route returns the precipitation data for a year from the most recent observation. Going forward, the next route will return a list of stations. Third route here: return dates and temperatures for one year from the most recent observation for the station with the most observations. These three routes were static routes, where there was a fixed route. The next two are dynamic routes, where we can make some changes to the route to get the desired output. For this first dynamic route, a start date can be customized in the route where the date, minimum, maximum, and average of temperature observations for the date are calculated starting from that start date and having all the observations after that date. And an end date is added for our next dynamic route, which performs the same function as the previous route, but the end date is also included and shows the data from start to end date, including the start and end dates. Then there is a command to run the app.
