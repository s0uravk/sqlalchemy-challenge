# sqlalchemy-challenge

![alchemy](https://github.com/s0uravk/sqlalchemy-challenge/assets/144293972/e10e7142-5304-45a2-936b-4d78f841192d)

This script access the File based database i.e. sqlite, to access the database objects to read the data and derive meaningful representation through plotting it using matplotlib library. While app.py file access the data using same method and outputs an API(Application Programming Interface) using various routes and data is reprsented in JSON format. This script shows the basic functionality of what goes on at the back end while an api is used to fetch the data and how to create an  API.

**Accessing data**

In climate_starter.ipynb, engine instances in created using local path of sqlite file which can be chnaged according to the database being access in following format "<protocol>://<username>:<password>@<server>:<port>/<fle-path>". In this case, protocol is sqlite, no need of username or password to access local sqlite file, server or host is localhost, no port required and then file path to the file to be accessed which is in Resources folder and named as hawaii.sqlite. automap_base instance is created to reflect the tables in sqlite file to be used in python code. Instance of each table is saved to fetch the data and session object is created to link python to database. Then data is being accessed using session.query and put in to the pandas dataframe which then is visualized using matplotlib library. Data visualization represents precipitation in inches for one year from the most recent obeservation.
Then minimumn, average and maximum of temprature obervations is calculated for the station with most observations. For the next visualization, data is represented in histogram for the frequency of different temptratures for one year from the most recent obeservation for the station with the most observations. Then session is closed once we are done with analysis.

**Creating an API**

For app.py file, at first, same method is used, to reflect the database structure and then creating instances of the tables to be accessed. Then , we create an instance for Flask named app and then homepage and other routes are created for the app. Here we can access the data in sqlite file using these routes in JSON format. Homepage lists the different routes we have in this app, then 2nd route return the precipitation data for a year from the most recent observation. Going forward, next route return a list of stations. Third route here, return dates and temptratures for one year from the most recent obeservation for the station with the most observations. These three routes were static routes where there is fixed route.
While next two are dynamic routes, where we can make some changes in route to get desired output. For this first dynamic route, a start date can be customzied in the route where date, minumum, maximum and average of temprature observations for the date is calculated starting from that start date and having all the observations after that date. And end date is added for our next dynamic route which performs the same function as previous route but end date is also included and shows the data from start to end date including start and end date.
Then, there is a command the run the app.
